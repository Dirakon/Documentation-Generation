["```\n<explanation>\nThe provided code defines an EO application named `app` that manages program version information by reading and writing data to files. It utilizes external commands for various operations like retrieving version numbers, reading/writing files, and logging.\n\nThe `app` object takes command-line arguments (`args`), extracts the state file path from the first argument, and then enters an infinite loop. Inside the loop, it retrieves external branch and program name and reads existing data of program from file, then fetches the current version using external commands, updates the data, and writes the updated data back to the state file using `program-data-storage`. Finally, it outputs the data as an RSS feed.\n\nThe supporting objects handle tasks such as managing program version data (`program-data`), interacting with external commands (`external`), and managing data storage in files (`program-data-storage`). It uses `QQ.fs` library for file system operations, `QQ.txt` for text manipulations, `QQ.io` for input/output operations, and `QQ.structs` for data structure manipulations. The infinite `while` loop suggests this application is intended to run continuously. The `program-data-storage` part encapsulates file operations, storing program metadata in specifically formatted files.\n</explanation>\n<doctest-code>\n[] > external\n  \"\" > @\n  \"|||\" > command-separator\n\n  [line-count] > line-counter\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"(lines: %d)\\n\"\n        * line-count\n\n  [content] > output-multiline\n    QQ.txt.text > text-content\n      content\n    split. > lines\n      text-content\n      \"\\n\"\n    seq > @\n      *\n        line-counter\n          lines.length\n        QQ.io.stdout\n          QQ.txt.sprintf\n            \"%s\\n\"\n            * content\n\n  [text] > log\n    seq > @\n      *\n        QQ.io.stdout\n          \"Log:\\n\"\n        output-multiline\n          text\n\n  [file content] > write\n    QQ.txt.text > write-file\n      \"write-file\"\n    seq > @\n      *\n        send-command\n          write-file.chained\n            * command-separator file.as-path\n        output-multiline content\n        get-confirmation\n\n  [file] > read\n    [items] > range\n      QQ.structs.range > @\n        []\n          [num] > build\n            num > @\n            build (@.plus 1) > next\n          build 0 > @\n        items\n    QQ.txt.text > read-file\n      \"read-file\"\n    seq > @\n      *\n        send-command\n          read-file.chained\n            * command-separator file.as-path\n        QQ.io.stdin.next-line > metadata\n        (QQ.txt.sscanf \"(lines: %d)\" metadata).at 0 > line-count\n        joined. > content\n          QQ.txt.text\n            \"\\n\"\n          mapped.\n            range\n              line-count\n            QQ.io.stdin.next-line > [i]\n        content\n\n  [command] > send-command\n    QQ.io.stdout > @\n      chained.\n        QQ.txt.text\n          \"Request: \"\n        *\n          QQ.txt.text\n            command\n          QQ.txt.text\n            \"\\n\"\n\n  [] > get-response\n    seq > @\n      *\n        QQ.io.stdin.next-line\n\n  [] > get-confirmation\n    seq > @\n      *\n        QQ.io.stdin.next-line\n\n  [branch program-name] > version\n    QQ.txt.text > get-version\n      \"get-version\"\n    seq > @\n      *\n        send-command\n          get-version.chained\n            * command-separator branch command-separator program-name\n        get-response > version-number\n        version-number\n\n  [] > branch\n    QQ.txt.text > get-branch\n      \"branch\"\n    seq > @\n      *\n        send-command\n          get-branch\n        get-response\n\n  [] > program-name\n    QQ.txt.text > program-name\n      \"program-name\"\n    seq > @\n      *\n        send-command\n          program-name\n        get-response\n\n[state-path] > program-data-storage\n  state-path > @\n  [branch program-name] > data-file\n    QQ.fs.file > file\n      QQ.fs.path.joined\n        *\n          state-path\n          QQ.fs.path\n            branch\n          QQ.fs.path\n            program-name\n    QQ.fs.dir > directory\n      QQ.fs.file\n        QQ.fs.path\n          file.dirname\n    seq > @\n      *\n        directory.made\n        file\n  [branch program-name] > read\n    data-file > file\n      branch\n      program-name\n    file.path > src\n    seq > @\n      *\n        if.\n          exists.\n            QQ.fs.file\n              src\n          seq\n            *\n              external.read > content\n                file\n              program-data\n                branch\n                program-name\n                mapped.\n                  QQ.structs.list\n                    split.\n                      content\n                      \"\\n\"\n                  [line] >>\n                    program-version > @\n                      at.\n                        QQ.txt.sscanf\n                          \"%s|||%d\"\n                          line\n                        0\n                      at.\n                        QQ.txt.sscanf\n                          \"%s|||%d\"\n                          line\n                        1\n          seq\n            *\n              program-data\n                branch\n                program-name\n                QQ.structs.list\n                  tuple.empty\n  [program-data-instance] > write\n    data-file > file\n      program-data-instance.branch\n      program-data-instance.program-name\n    seq > @\n      *\n        program-data-instance.versions.reduced > serialized-versions\n          QQ.txt.text\n            \"\"\n          [accum version]\n            chained. > @\n              accum\n              *\n                QQ.txt.text\n                  version.version-number\n                QQ.txt.text\n                  \"|||\"\n                QQ.txt.text\n                  QQ.txt.sprintf\n                    \"%d\"\n                    * version.timestamp\n                QQ.txt.text\n                  \"\\n\"\n        external.log\n          serialized-versions\n        external.write\n          file\n          serialized-versions\n        program-data-instance\n\n[branch program-name versions] > program-data\n  program-name > @\n\n  # Have some weird stackoverflow problems if I try to separate rss-string creation and the output.\n  # Therefore, I have to break responsibilities here and unify rss-string creation and the ouput.\n  [] > output-as-rss\n    QQ.txt.sprintf > prefix\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<rss version=\\\"2.0\\\">\\n\\n<channel>\\n  <title>%s versions</title>\\n  <link>https://search.nixos.org/packages?channel=%s&from=0&size=50&sort=relevance&type=packages&query=%s</link>\\n  <description>History of versions</description>\"\n      * program-name branch program-name\n    [] > output-middle-part\n      seq > @\n        mapped.\n          versions\n          [version] >>\n            QQ.io.stdout > @\n              QQ.txt.sprintf\n                \"  <item>\\n    <title>%s</title>\\n    <link>https://search.nixos.org/packages?channel=%s&from=0&size=50&sort=relevance&type=packages&query=%s</link>\\n    <description>New version at %d</description>\\n  </item>\\n\"\n                * version.version-number branch program-name version.timestamp\n    \"</channel>\\n\\n</rss>\" > suffix\n    seq > @\n      *\n        QQ.io.stdout\n          \"Rss:\\n\"\n        5.times versions.length > number-of-lines-middle\n        7 > prefix-lines\n        3 > suffix-lines\n        (number-of-lines-middle.plus prefix-lines).plus suffix-lines > number-of-lines\n        external.line-counter number-of-lines\n        QQ.io.stdout\n          prefix\n        QQ.io.stdout\n          \"\\n\"\n        output-middle-part\n        QQ.io.stdout\n          suffix\n        QQ.io.stdout\n          \"\\n\"\n\n  # \n  [new-version] > actualized\n    program-data > @\n      branch\n      program-name\n      if.\n        and.\n          eq.\n            last-index-of.\n              versions\n              new-version\n            versions.length.minus 1\n          not.\n            versions.is-empty\n        versions\n        versions.with new-version\n\n# \n[version-number timestamp] > program-version\n  version-number > @\n\n[args] > app\n  QQ.fs.path > state-path\n    args.at 0\n  seq > @\n    *\n      while\n        1 > i\n        [i] >>\n          seq > @\n            *\n              external.branch > branch\n              external.program-name > program-name\n              external.log\n                \"Reading...\"\n              currently-saved-data > data\n                branch\n                program-name\n              external.log\n                \"Getting current version\"\n              version > current-version\n                branch\n                program-name\n              data.actualized > new-data\n                current-version\n              program-data-storage > storage\n                state-path\n              external.log\n                \"Writing...\"\n              storage.write\n                new-data\n              new-data.output-as-rss\n              false\n\n  [branch program-name] > version\n    seq > @\n      *\n        external.version > version-number\n          branch\n          program-name\n        program-version\n          version-number\n          1678886400 # Fixed timestamp for testing\n\n  [branch program-name] > currently-saved-data\n    seq > @\n      *\n        program-data-storage > storage\n          state-path\n        storage.read > data\n          branch\n          program-name\n\n  [] > current-time\n    output. > @\n      QQ.sys.posix\n        \"gettimeofday\"\n        * QQ.sys.posix.timeval\n\n[arg] > doctest\n  app > @\n    *\n      arg\n\n</doctest-code>\n<doctest-stdin>\ntest_state_path\nRequest: branch\ntest_branch\nRequest: program-name\ntest_program\nLog:\nReading...\nRequest: read-file|||test_state_path/test_branch/test_program\n(lines: 0)\nLog:\nGetting current version\nRequest: get-version|||test_branch|||test_program\n1.2.3\nLog:\nWriting...\nRequest: write-file|||test_state_path/test_branch/test_program\nLog:\nRss:\n(lines: 12)\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n\n<channel>\n  <title>test_program versions</title>\n  <link>https://search.nixos.org/packages?channel=test_branch&from=0&size=50&sort=relevance&type=packages&query=test_program</link>\n  <description>History of versions</description>\n  <item>\n    <title>1.2.3</title>\n    <link>https://search.nixos.org/packages?channel=test_branch&from=0&size=50&sort=relevance&type=packages&query=test_program</link>\n    <description>New version at 1678886400</description>\n  </item>\n</channel>\n\n</rss>\n\n</doctest-stdin>\n<doctest-output>\nRss:\n(lines: 12)\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n\n<channel>\n  <title>test_program versions</title>\n  <link>https://search.nixos.org/packages?channel=test_branch&from=0&size=50&sort=relevance&type=packages&query=test_program</link>\n  <description>History of versions</description>\n  <item>\n    <title>1.2.3</title>\n    <link>https://search.nixos.org/packages?channel=test_branch&from=0&size=50&sort=relevance&type=packages&query=test_program</link>\n    <description>New version at 1678886400</description>\n  </item>\n</channel>\n\n</rss>\n\n</doctest-output>\n```","```\n<explanation>\nThe code defines an object `program-data-storage` that manages the storage and retrieval of program data. It takes `state-path` as an argument, which specifies the location where data will be stored.\n\nHere's a breakdown:\n\n-   `data-file`: This function takes a `branch` and `program-name` and constructs a file path where the data is stored. It creates the necessary directories if they don't exist.\n\n-   `read`: This function takes `branch` and `program-name` and reads the program data from the corresponding file. If the file exists, it reads the content, splits it into lines, and parses each line as a `program-version`. If the file doesn't exist, it returns an empty list of versions. Deserialization process is happening here.\n\n-   `write`: This function takes a `program-data-instance` as input and writes the serialized version data to a file. It formats each version and timestamp into a string, concatenates them with \"|||\" as a separator, and joins the resulting lines with newline characters, then calls the `external` interface to physically write the content to disk. Serialization process is happening here.\n</explanation>\n<doctest-code>\n```eo\n[] > external\n  [command] > send-command\n    QQ.io.stdout > @\n      command\n\n  [file content] > write\n    seq > @\n      *\n        send-command\n          \"writing to \"\n          #file\n        QQ.io.stdout\n          content\n\n  [file] > read\n    seq > @\n      *\n        send-command\n          \"reading \"\n          #file\n        \"v1|||123\\nv2|||456\" > @\n\n[] > program-data-storage-test\n  QQ.txt.text > state-path\n    \"test_state\"\n  program-data-storage > storage\n    state-path\n  [] > doctest\n    seq > @\n      *\n        storage.write > dummy-write\n          program-data\n            \"test-branch\"\n            \"test-program\"\n            (QQ.structs.list\n              (tuple\n                \"v1\"\n                123)\n              (tuple\n                \"v2\"\n                456))\n        #dummy-write.branch\n        #dummy-write.program-name\n        #dummy-write.versions.length\n        #dummy-write.versions.at 0\n        #dummy-write.versions.at 1\n        storage.read > dummy-read\n          \"test-branch\"\n          \"test-program\"\n        #dummy-read.branch\n        #dummy-read.program-name\n        #dummy-read.versions.length\n        #dummy-read.versions.at 0\n        #dummy-read.versions.at 1\n        QQ.io.stdout\n          \"done\"\n\n  [branch program-name versions] > program-data\n    branch > @\n    {} > @alias\n       branch\n\n# Will print contents of writing to standard output, as well as result of reading, and also print strings, program, versions information.\n```\n</doctest-code>\n<doctest-stdin>\n</doctest-stdin>\n<doctest-output>\nwriting to test_state/test-branch/test-program\nv1|||123\nv2|||456\nv1|||123\nv2|||456\ndone\n</doctest-output>\n```","```\n<explanation>\nThe provided EO code defines an object `program-data` with the following functionality:\n\n1.  **`output-as-rss`**: Generates and prints an RSS feed containing the versions of a program. It constructs the RSS feed by combining a prefix, a middle part (which iterates over the versions), and a suffix. It also logs number of lines in generated RSS feed.\n2.  **`actualized`**: Takes a `new-version` as input and adds it to the `versions` list if it's not already the latest version. It checks for duplicate last versions before adding to avoid duplicates. Implemented this check with `eq` comparision and `last-index-of` function from structs lib.\n\nAdditionally, it introduces the concepts `program-version` which allows to create a `version` containing `version-number` and `timestamp`. It takes 2 parameters: `version-number` and `timestamp`.\nThe `external` object introduces abstractions for interacting with the outside world, providing functions such as:\n* `log`\n* `output-multiline`\n* `write`\n* `read`\n* `send-command`\n* `get-response`\n* `get-confirmation`\n* `version`\n* `branch`\n* `program-name`\nBesides that the `program-data-storage` defines data persistence layer and `app` is an application which uses previous layers to work with the state.\n\n</explanation>\n<doctest-code>\n[] > external\n  \"test\" > @\n  \"|||\" > command-separator\n\n  [line-count] > line-counter\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"(lines: %d)\\n\"\n        * line-count\n\n  [text] > log\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"Log: %s\\n\"\n        * text\n\n  [file content] > write\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"Write to %s: %s\\n\"\n        * file.as-path content\n\n  [file] > read\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"Read from %s\\n\"\n        * file.as-path\n\n  [command] > send-command\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"Request: %s\\n\"\n        * command\n\n  [] > get-response\n    QQ.io.stdin.next-line > @\n\n  [] > get-confirmation\n    QQ.io.stdin.next-line > @\n\n  [branch program-name] > version\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"Version for %s/%s\\n\"\n        * branch program-name\n\n  [] > branch\n    \"test-branch\" > @\n\n  [] > program-name\n    \"test-program\" > @\n\n[branch program-name versions] > program-data\n  program-name > @\n\n  # Have some weird stackoverflow problems if I try to separate rss-string creation and the output.\n  # Therefore, I have to break responsibilities here and unify rss-string creation and the ouput.\n  [] > output-as-rss\n    QQ.txt.sprintf > prefix\n      \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<rss version=\\\"2.0\\\">\\n\\n<channel>\\n  <title>%s versions</title>\\n  <link>https://search.nixos.org/packages?channel=%s&from=0&size=50&sort=relevance&type=packages&query=%s</link>\\n  <description>History of versions</description>\"\n      * program-name branch program-name\n    [] > output-middle-part\n      seq > @\n        mapped.\n          versions\n          [version] >>\n            QQ.io.stdout > @\n              QQ.txt.sprintf\n                \"  <item>\\n    <title>%s</title>\\n    <link>https://search.nixos.org/packages?channel=%s&from=0&size=50&sort=relevance&type=packages&query=%s</link>\\n    <description>New version at %d</description>\\n  </item>\\n\"\n                * version.version-number branch program-name version.timestamp\n    \"</channel>\\n\\n</rss>\" > suffix\n    seq > @\n      *\n        QQ.io.stdout\n          \"Rss:\\n\"\n        5.times versions.length > number-of-lines-middle\n        7 > prefix-lines\n        3 > suffix-lines\n        (number-of-lines-middle.plus prefix-lines).plus suffix-lines > number-of-lines\n        external.line-counter number-of-lines\n        QQ.io.stdout\n          prefix\n        QQ.io.stdout\n          \"\\n\"\n        output-middle-part\n        QQ.io.stdout\n          suffix\n        QQ.io.stdout\n          \"\\n\"\n\n  # \n  [new-version] > actualized\n    program-data > @\n      branch\n      program-name\n      if.\n        and.\n          eq.\n            last-index-of.\n              versions\n              new-version\n            versions.length.minus 1\n          not.\n            versions.is-empty\n        versions\n        versions.with new-version\n\n# \n[version-number timestamp] > program-version\n  version-number > @\n\n[] > doctest\n  program-data > data\n    \"test-branch\"\n    \"test-program\"\n    *\n      tuple.empty\n  program-version > version1\n    \"1.0\"\n    1678886400\n  program-data.actualized > data2\n    data\n    version1\n  program-version > version2\n    \"2.0\"\n    1678972800\n  program-data.actualized > data3\n    data2\n    version2\n  data3.output-as-rss\n</doctest-code>\n<doctest-stdin>\n</doctest-stdin>\n<doctest-output>\nRss:\n(lines: 12)\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n\n<channel>\n  <title>test-program versions</title>\n  <link>https://search.nixos.org/packages?channel=test-branch&from=0&size=50&sort=relevance&type=packages&query=test-program</link>\n  <description>History of versions</description>\n  <item>\n    <title>1.0</title>\n    <link>https://search.nixos.org/packages?channel=test-branch&from=0&size=50&sort=relevance&type=packages&query=test-program</link>\n    <description>New version at 1678886400</description>\n  </item>\n  <item>\n    <title>2.0</title>\n    <link>https://search.nixos.org/packages?channel=test-branch&from=0&size=50&sort=relevance&type=packages&query=test-program</link>\n    <description>New version at 1678972800</description>\n  </item>\n</channel>\n\n</rss>\n\n</doctest-output>\n```","```\n<explanation>\nThe code defines a method `program-data.actualized` which takes a `new-version` as input and returns an updated `program-data` object. The new `program-data` object contains the same `branch` and `program-name` as the original. The `versions` list within the object is updated based on whether the `new-version` is already the last element in the `versions` list.\nIf the `new-version` is already the last version (and the versions list is not empty) which means that the version wasn't changed, the old list is returned, otherwise the `new-version` is added to versions.\n</explanation>\n<doctest-code>\n[] > external\n  \"\" > @\n  \"Test\" > branch\n  \"TestProgram\" > program-name\n  [text] > log\n    QQ.io.stdout > @\n      text\n  [file content] > write\n    QQ.io.stdout > @\n      content\n  [file] > read\n    QQ.io.stdout > @\n      \"1.0|||1678886400\\n\"\n  [command] > send-command\n    QQ.io.stdout > @\n      command\n  [] > get-response\n    \"1.0\" > @\n  [] > get-confirmation\n    \"OK\" > @\n  [branch program-name] > version\n    \"1.0\" > @\n  [line-count] > line-counter\n    QQ.io.stdout > @\n      line-count\n\n[args] > app\n  \"path\" > state-path\n  seq > @\n    *\n      while\n        false > [i] >>\n        external.branch > branch\n\n[branch program-name versions] > program-data\n  program-name > @\n  [] > output-as-rss\n    QQ.io.stdout\n      \"Output\"\n  [new-version] > actualized\n    program-data > @\n      program-name\n      program-name\n      if.\n        and.\n          eq.\n            last-index-of.\n              versions\n              new-version\n            versions.length.minus 1\n          not.\n            versions.is-empty\n        versions\n        versions.with new-version\n\n[version-number timestamp] > program-version\n  version-number > @\n\n[version-number timestamp] > doctest-version\n  version-number > @\n\n[version-number timestamp] > version_1\n  version-number > @\n[version-number timestamp] > version_2\n  version-number > @\n[version-number timestamp] > version_3\n  version-number > @\n\n[] > doctest\n  program-data > initial-data\n    \"test-branch\"\n    \"test-program\"\n    *\n      version_1\n        \"1.0\"\n        1234567890\n      version_2\n        \"2.0\"\n        1234567891\n  doctest-version > new-version\n    \"2.0\"\n    1234567892\n  initial-data.actualized > result\n    new-version\n  QQ.io.stdout > @\n    result.versions.length\n</doctest-code>\n<doctest-stdin>\n</doctest-stdin>\n<doctest-output>\n2\n</doctest-output>\n```","```\n<explanation>\nThe provided code defines an object `program-version` that represents a specific version of a program. It encapsulates the version number (a string) and a timestamp (an integer). The object takes `version-number timestamp` as arguments and evaluates to the `version-number`.\n</explanation>\n<doctest-code>\n[] > external\n  \"\" > @\n  \"|||\" > command-separator\n\n  [line-count] > line-counter\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"(lines: %d)\\n\"\n        * line-count\n\n  [content] > output-multiline\n    QQ.txt.text > text-content\n      content\n    split. > lines\n      text-content\n      \"\\n\"\n    seq > @\n      *\n        line-counter\n          lines.length\n        QQ.io.stdout\n          QQ.txt.sprintf\n            \"%s\\n\"\n            * content\n\n  [text] > log\n    seq > @\n      *\n        QQ.io.stdout\n          \"Log:\\n\"\n        output-multiline\n          text\n\n  [file content] > write\n    QQ.txt.text > write-file\n      \"write-file\"\n    seq > @\n      *\n        send-command\n          write-file.chained\n            * command-separator file.as-path\n        output-multiline content\n        get-confirmation\n\n  [file] > read\n    [items] > range\n      QQ.structs.range > @\n        []\n          [num] > build\n            num > @\n            build (@.plus 1) > next\n          build 0 > @\n        items\n    QQ.txt.text > read-file\n      \"read-file\"\n    seq > @\n      *\n        send-command\n          read-file.chained\n            * command-separator file.as-path\n        QQ.io.stdin.next-line > metadata\n        (QQ.txt.sscanf \"(lines: %d)\" metadata).at 0 > line-count\n        joined. > content\n          QQ.txt.text\n            \"\\n\"\n          mapped.\n            range\n              line-count\n            QQ.io.stdin.next-line > [i]\n        content\n\n  [command] > send-command\n    QQ.io.stdout > @\n      chained.\n        QQ.txt.text\n          \"Request: \"\n        *\n          QQ.txt.text\n            command\n          QQ.txt.text\n            \"\\n\"\n\n  [] > get-response\n    seq > @\n      *\n        QQ.io.stdin.next-line\n\n  [] > get-confirmation\n    seq > @\n      *\n        QQ.io.stdin.next-line\n\n  [branch program-name] > version\n    QQ.txt.text > get-version\n      \"get-version\"\n    seq > @\n      *\n        send-command\n          get-version.chained\n            * command-separator branch command-separator program-name\n        get-response > version-number\n        version-number\n\n  [] > branch\n    QQ.txt.text > get-branch\n      \"branch\"\n    seq > @\n      *\n        send-command\n          get-branch\n        get-response\n\n  [] > program-name\n    QQ.txt.text > program-name\n      \"program-name\"\n    seq > @\n      *\n        send-command\n          program-name\n        get-response\n\n[version-number timestamp] > program-version\n  version-number > @\n\n[] > doctest\n  program-version > @\n    \"1.2.3\"\n    1678886400\n</doctest-code>\n<doctest-stdin>\n</doctest-stdin>\n<doctest-output>\n1.2.3\n</doctest-output>\n```","```\n<explanation>\nThis code defines an object named `external` which encapsulates interactions with external systems (likely through standard input/output). It provides functionalities for logging, file reading/writing, retrieving version numbers, and managing program and branch names. These interactions are simulated through specific commands sent to standard output, and responses or confirmations read from standard input. Basically the code emulates an external shell-like environment with predefined commands.\n</explanation>\n<doctest-code>\n[] > external\n  \"\" > @\n  \"|||\" > command-separator\n\n  [line-count] > line-counter\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"(lines: %d)\\n\"\n        * line-count\n\n  [content] > output-multiline\n    QQ.txt.text > text-content\n      content\n    split. > lines\n      text-content\n      \"\\n\"\n    seq > @\n      *\n        line-counter\n          lines.length\n        QQ.io.stdout\n          QQ.txt.sprintf\n            \"%s\\n\"\n            * content\n\n  [text] > log\n    seq > @\n      *\n        QQ.io.stdout\n          \"Log:\\n\"\n        output-multiline\n          text\n\n  [file content] > write\n    QQ.txt.text > write-file\n      \"write-file\"\n    seq > @\n      *\n        send-command\n          write-file.chained\n            * command-separator file.as-path\n        output-multiline content\n        get-confirmation\n\n  [file] > read\n    [items] > range\n      QQ.structs.range > @\n        []\n          [num] > build\n            num > @\n            build (@.plus 1) > next\n          build 0 > @\n        items\n    QQ.txt.text > read-file\n      \"read-file\"\n    seq > @\n      *\n        send-command\n          read-file.chained\n            * command-separator file.as-path\n        QQ.io.stdin.next-line > metadata\n        (QQ.txt.sscanf \"(lines: %d)\" metadata).at 0 > line-count\n        joined. > content\n          QQ.txt.text\n            \"\\n\"\n          mapped.\n            range\n              line-count\n            QQ.io.stdin.next-line > [i]\n        content\n\n  [command] > send-command\n    QQ.io.stdout > @\n      chained.\n        QQ.txt.text\n          \"Request: \"\n        *\n          QQ.txt.text\n            command\n          QQ.txt.text\n            \"\\n\"\n\n  [] > get-response\n    seq > @\n      *\n        QQ.io.stdin.next-line\n\n  [] > get-confirmation\n    seq > @\n      *\n        QQ.io.stdin.next-line\n\n  [branch program-name] > version\n    QQ.txt.text > get-version\n      \"get-version\"\n    seq > @\n      *\n        send-command\n          get-version.chained\n            * command-separator branch command-separator program-name\n        get-response > version-number\n        version-number\n\n  [] > branch\n    QQ.txt.text > get-branch\n      \"branch\"\n    seq > @\n      *\n        send-command\n          get-branch\n        get-response\n\n  [] > program-name\n    QQ.txt.text > program-name\n      \"program-name\"\n    seq > @\n      *\n        send-command\n          program-name\n        get-response\n\n[] > doctest\n  seq > @\n    *\n      external.log\n        \"test log message\"\n      external.write\n        \"test_file.txt\"\n        \"content line 1\\ncontent line 2\"\n      external.read\n        \"test_file.txt\"\n      external.version\n        \"test_branch\"\n        \"test_program\"\n      external.branch\n      external.program-name\n</doctest-code>\n<doctest-stdin>\nRequest: write-file|||test_file.txt\n(lines: 2)\nConfirmation\nRequest: get-version|||test_branch|||test_program\n1.2.3\nRequest: branch\ntest_branch_name\nRequest: program-name\ntest_program_name\n</doctest-stdin>\n<doctest-output>\nLog:\n(lines: 1)\ntest log message\nRequest: write-file|||test_file.txt\n(lines: 2)\ncontent line 1\ncontent line 2\nConfirmation\nRequest: read-file|||test_file.txt\nRequest: get-version|||test_branch|||test_program\nRequest: branch\nRequest: program-name\n</doctest-output>\n```"]