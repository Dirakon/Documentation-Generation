["```\n<explanation>\nThis code defines a program that manages and outputs version information in RSS format. The `app` object is the main entry point, taking a single argument representing the state path. It continuously reads, processes and writes data related to versions of a program. The program interacts with external resources through the `external` object to read files, retrieve version information, and log messages. The `program-data-storage` is responsible for reading and writing version data to files. The data is then formatted and  presented as an RSS feed.\n</explanation>\n<doctest-code>\n[args] > doctest\n  QQ.io.stdout > @\n    \"doctest\"\n</doctest-code>\n<doctest-stdin>\n</doctest-stdin>\n<doctest-output>\ndoctest\n</doctest-output>\n```","```\n<explanation>\nThe `program-data-storage` object is responsible for managing the storage and retrieval of program data from the file system. It takes the state path as an argument, which is then used to construct the path to the data files. It defines three functions: `data-file`, `read`, and `write`.\n\n`data-file`: This function creates the file path for storing program data. It combines the provided `state-path`, `branch`, and `program-name` to generate the full path to the data file using `QQ.fs.path.joined`. Before generating path it also creates the directory using `QQ.fs.dir.made`.\n`read`: This function reads the program data from the file specified by the `data-file` function. Using external.read to get string content, then splits it into lines, which represent program versions. Then it parses each line into a `program-version` object, which extracts version-number and timestamp using sscanf. The results of `program-version` are returned from the function as array.\n`write`: This function writes the provided program data to the file. Before witing the data to the file it serializes the versions to the string. Each version is serialized as \"version-number|||timestamp\\n\".  It then utilizes `external.write` for the actual file writing operation.\n\n</explanation>\n<doctest-code>\n[args] > entry-function\n  qq-app > @\n    \"test-path\"\n    \"test-branch\"\n    \"test-program\"\n\n[state-path branch program-name] > qq-app\n  program-data-storage > storage\n    state-path\n  write-and-read > @\n    storage\n    branch\n    program-name\n\n[storage branch program-name] > write-and-read\n  *\n    \"v1|||123\"\n    \"v2|||456\"\n  > versions\n\n  storage.write > write-result\n    * branch program-name versions\n\n  storage.read > read-result\n    branch\n    program-name\n  read-result > @\n\n[] > external\n  [file content] > write\n    QQ.io.stdout > @\n      \"write: \"\n    QQ.io.stdout\n      content\n    \n\n  [file] > read\n    QQ.io.stdout > @\n      \"read: \"\n    QQ.io.stdout\n      file\n    \"v1|||123\\nv2|||456\\n\"\n\n[] > QQ\n  [] > io\n    [] > stdout\n      [text] > @\n        text\n  [] > fs\n    [] > path\n      [joined] > @\n        \"path_joined: \"\n        args.at 0\n        args.at 1\n        args.at 2\n    [] > file\n      [dirname] > @\n        \"dirname_result\"\n    [] > dir\n      [] > made\n        \"made_result\"\n  [] > structs\n    [] > list\n      [tuple.empty] > @\n        \"empty_list\"\n\n  [] > txt\n    [sprintf] > @\n      args.at 0\n      args.at 1\n      args.at 2\n\n    [text] > @\n      args.at 0\n</doctest-code>\n<doctest-stdin>\n</doctest-stdin>\n<doctest-output>\nwrite: v1|||123\nv2|||456\nread: path_joined: test-path\ntest-branch\ntest-program\n</doctest-output>\n```","```\n<explanation>\n`program-data` is a function that encapsulates the logic for generating and outputting RSS feeds based on program version data. It takes three arguments: `branch`, `program-name`, and `versions`. Within this function:\n\n1.  `output-as-rss`: This is a parameterless function responsible for generating the RSS feed string and printing it to standard output. The function constructs an RSS feed using `QQ.txt.sprintf`, including the title, link, and description. It iterates through the `versions` list, creating an item for each version with its title, link, and description. Finally, it outputs the closing tags of the RSS feed.\n2.  `actualized`: This function updates the list of versions. It takes a `new-version` as an argument, compares it to the existing versions and returns either the original list of versions or a new list with the new version appended.\n3.  `program-version`: This function takes `version-number` and `timestamp` and returns the `version-number`.\n\n</explanation>\n<doctest-code>\n[args] > doctest\n  QQ.fs.path > doctest-state-path\n    \"doctest-state-path\"\n  seq > @\n    *\n      [branch program-name versions] > program-data-doctest\n        program-name > @\n        [] > output-as-rss\n          QQ.txt.text > prefix\n            \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<rss version=\\\"2.0\\\">\\n\\n<channel>\\n  <title>%s versions</title>\\n  <link>https://search.nixos.org/packages?channel=%s&from=0&size=50&sort=relevance&type=packages&query=%s</link>\\n  <description>History of versions</description>\"\n          QQ.txt.text versions.length > versions-length\n          QQ.io.stdout > @\n            QQ.txt.sprintf\n              \"%s\\n%s</channel>\\n\\n</rss>\\n\"\n              * prefix \"test-program-name\" \"test-branch\" \"test-program-name\"\n                versions-length\n        [new-version] > actualized\n          program-data-doctest\n            branch\n            program-name\n            versions\n        #\n      [branch program-name] > test-version-1\n        QQ.structs.list\n          \"version-number-1\"\n          \"1678886400\"\n      [branch program-name] > test-version-2\n        QQ.structs.list\n          \"version-number-2\"\n          \"1678886400\"\n      QQ.structs.list > versions-arg\n        test-version-1\n      program-data-doctest > main-output\n        \"test-branch\"\n        \"test-program-name\"\n        versions-arg\n</doctest-code>\n<doctest-stdin>\n</doctest-stdin>\n<doctest-output>\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<rss version=\"2.0\">\n\n<channel>\n  <title>test-program-name versions</title>\n  <link>https://search.nixos.org/packages?channel=test-branch&from=0&size=50&sort=relevance&type=packages&query=test-program-name</link>\n  <description>History of versions</description>\n1</channel>\n\n</rss>\n</doctest-output>\n```","```\n<explanation>\nThe `actualized` function within the `program-data` object serves to update the version history of a program. It takes a `new-version` object as input and determines whether to add it to the existing list of versions based on certain conditions. If the `new-version` is not already present at the end of  `versions` and `versions` is not empty it will append it to the version list returning updated list of versions.\n</explanation>\n<doctest-code>\n[version-number timestamp] > program-version\n  version-number > @\n\n[program-version1] > version.v1\n  \"1.0\"\n  1678886400\n\n[program-version2] > version.v2\n  \"2.0\"\n  1678893600\n\n[program-version3] > version.v3\n  \"2.1\"\n  1678900800\n\n[] > external\n  [] > branch\n    \"main\"\n  [] > program-name\n    \"test-program\"\n\n  [text] > log\n    \"Log: \" > @\n\n[branch program-name versions] > program-data\n  program-name > @\n\n  [] > output-as-rss\n    \"\" > @\n  [new-version] > actualized\n    program-data > @\n      branch\n      program-name\n      if.\n        and.\n          eq.\n            last-index-of.\n              versions\n              new-version\n            versions.length.minus 1\n          not.\n            versions.is-empty\n        versions\n        versions.with new-version\n\n[] > doctest\n  program-data.actualized > @\n    external.branch\n    external.program-name\n    *\n      version.v1\n      version.v2\n    version.v3\n</doctest-code>\n<doctest-stdin>\n</doctest-stdin>\n<doctest-output>\n(test-program\n((1.0 1678886400) (2.0 1678893600) (2.1 1678900800)))\n</doctest-output>\n```","```\n<explanation>\nThis code defines a function `program-version` that takes a version number and a timestamp as inputs and returns the version number. It serves as a simple data structure or a getter for the version number part of the program version information.\n</explanation>\n<doctest-code>\n[] > doctest\n  QQ.io.stdout > @\n    program-version\n      \"1.2.3\"\n      1678886400\n</doctest-code>\n<doctest-stdin>\n</doctest-stdin>\n<doctest-output>\n1.2.3\n</doctest-output>\n```","```\n<explanation>\nThis code defines an `external` object, which serves as an interface to interact with the operating system or an external environment. It abstracts away system calls and file operations, providing a simplified API for the main application logic. The `external` object primarily uses `QQ.io.stdout`, `QQ.io.stdin`, and `QQ.fs` functionalities to simulate external behavior.\n\nKey Components:\n\n*   `@`: Defines the output of the entire object.\n*   `command-separator`: A string used to separate commands and arguments when communicating with the external environment.\n*   `line-counter`: Logs the number of lines to standard output. It takes a `line-count` as input.\n*   `output-multiline`: Takes a `content` string, then splits it by newlines and logs them individually with a count to the standard output.\n*   `log`: Logs the text to the standard output with a \"Log:\\n\" prefix, using `output-multiline`.\n*   `write`: Writes `content` to a file specified by `file`. It simulates the write operation with `external.send-command` and logs the provided content.\n*   `read`: Reads a file, specified by `file`, mimicking how file read occurs (but doesn't actually use any file system). It gets the number of lines from stdin (simulating metadata) and, then reads each line, joining all retrieved lines using newlines.\n*   `send-command`: Outputs the command to be executed via standard output (simulating external command execution).\n*   `get-response`: Reads a line from standard input, simulating the response from an external process.\n*   `get-confirmation`: Reads a line from standard input, simulating a confirmation message.\n*   `version`: Retrieves the version number for of a program on a given branch from an external system, using `send-command` to send the command, and `get-response` to receive the version number.\n*   `branch`: Retrieves the current branch through `send-command` and `get-response`.\n*   `program-name`: Retrieves the program name from an external source using `send-command` and `get-response`.\n\nIn essence, `external` defines a set of functions to interact with an environment (such as a filesystem, or an external process) by simulating those interactions via `QQ.io.stdout` and `QQ.io.stdin`.\n</explanation>\n<doctest-code>\n[args] > doctest\n  QQ.fs.path > state-path\n    args.at 0\n  seq > @\n    *\n      external.branch > branch\n      external.program-name > program-name\n      branch > branch-name\n      program-name > program-name-value\n\n  [] > args\n    \"test-state-path\" > @\n\n[] > external\n  \"\" > @\n  \"|||\" > command-separator\n\n  [line-count] > line-counter\n    QQ.io.stdout > @\n      QQ.txt.sprintf\n        \"(lines: %d)\\n\"\n        * line-count\n\n  [content] > output-multiline\n    QQ.txt.text > text-content\n      content\n    split. > lines\n      text-content\n      \"\\n\"\n    seq > @\n      *\n        line-counter\n          lines.length\n        QQ.io.stdout\n          QQ.txt.sprintf\n            \"%s\\n\"\n            * content\n\n  [text] > log\n    seq > @\n      *\n        QQ.io.stdout\n          \"Log:\\n\"\n        output-multiline\n          text\n\n  [file content] > write\n    QQ.txt.text > write-file\n      \"write-file\"\n    seq > @\n      *\n        send-command\n          write-file.chained\n            * command-separator file.as-path\n        output-multiline content\n        get-confirmation\n\n  [file] > read\n    [items] > range\n      QQ.structs.range > @\n        []\n          [num] > build\n            num > @\n            build (@.plus 1) > next\n          build 0 > @\n        items\n    QQ.txt.text > read-file\n      \"read-file\"\n    seq > @\n      *\n        send-command\n          read-file.chained\n            * command-separator file.as-path\n        QQ.io.stdin.next-line > metadata\n        (QQ.txt.sscanf \"(lines: %d)\" metadata).at 0 > line-count\n        joined. > content\n          QQ.txt.text\n            \"\\n\"\n          mapped.\n            range\n              line-count\n            QQ.io.stdin.next-line > [i]\n        content\n\n  [command] > send-command\n    QQ.io.stdout > @\n      chained.\n        QQ.txt.text\n          \"Request: \"\n        *\n          QQ.txt.text\n            command\n          QQ.txt.text\n            \"\\n\"\n\n  [] > get-response\n    seq > @\n      *\n        QQ.io.stdin.next-line\n\n  [] > get-confirmation\n    seq > @\n      *\n        QQ.io.stdin.next-line\n\n  [branch program-name] > version\n    QQ.txt.text > get-version\n      \"get-version\"\n    seq > @\n      *\n        send-command\n          get-version.chained\n            * command-separator branch command-separator program-name\n        get-response > version-number\n        version-number\n\n  [] > branch\n    QQ.txt.text > get-branch\n      \"branch\"\n    seq > @\n      *\n        send-command\n          get-branch\n        get-response\n\n  [] > program-name\n    QQ.txt.text > program-name\n      \"program-name\"\n    seq > @\n      *\n        send-command\n          program-name\n        get-response\n</doctest-code>\n<doctest-stdin>\nbranch-name\nprogram-name-value\n</doctest-stdin>\n<doctest-output>\nRequest: branch\nbranch-name\nRequest: program-name\nprogram-name-value\n</doctest-output>\n```"]